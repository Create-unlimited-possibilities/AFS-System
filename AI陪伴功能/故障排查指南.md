# 故障排查指南

## 目录
1. [Jest测试问题](#g1-jest测试问题)
2. [容器环境问题](#g2-容器环境问题)
3. [LangChain集成问题](#g3-langchain集成问题)
4. [数据模型问题](#g4-数据模型问题)
5. [服务集成问题](#g5-服务集成问题)
6. [Phase 3对话功能问题](#g6-phase-3对话功能问题)

---

## G1. Jest测试问题

### 问题1: ReferenceError: require is not defined

**症状**:
```
FAIL tests/unit/dualStorage.test.js
  ● Test suite failed to run
    ReferenceError: require is not defined
      at tests/unit/dualStorage.test.js:15:26
      at _getJestObj (tests/unit/dualStorage.test.js:15:1)
```

**原因**:
- ES模块环境中无法使用CommonJS的`require()`
- `package.json`中设置了`"type": "module"`
- Jest在ES模块环境中的mock支持有限

**解决方案**:

#### 方案A: 转换测试文件为CommonJS
1. 将测试文件重命名为`.cjs`扩展名
```bash
mv tests/unit/sentimentManager.test.js tests/unit/sentimentManager.test.cjs
```

2. 修改导入语法
```javascript
// 从
import { jest } from '@jest/globals';
// 改为
const { jest } = require('@jest/globals');
```

3. 更新Jest配置
```javascript
// jest.config.cjs
module.exports = {
  // ...其他配置
  testMatch: ['**/?(*.)+(spec|test).cjs']
};
```

#### 方案B: 降级Jest版本
1. 卸载当前版本
```bash
npm uninstall jest
```

2. 安装27.x版本（更好的ESM支持）
```bash
npm install jest@27.5.1 --save-dev
npm install babel-jest@27.5.1 --save-dev
```

#### 方案C: 迁移到Vitest
1. 安装Vitest
```bash
npm install -D vitest
```

2. 创建配置文件
```javascript
// vitest.config.js
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node'
  }
});
```

### 问题2: Coverage threshold not met

**症状**:
```
Jest: "global" coverage threshold for statements (80%) not met: 8.52%
```

**原因**:
- 测试覆盖率未达到配置的阈值
- 主要是因为单元测试无法执行

**解决方案**:
1. **查看详细覆盖率报告**
```bash
# 生成HTML报告
npm run test:coverage
# 查看报告
open coverage/lcov-report/index.html
```

2. **添加缺失的测试用例**
   - 重点测试未覆盖的代码行
   - 优先测试核心逻辑

3. **临时降低阈值**（仅用于开发）
```javascript
// jest.config.cjs
coverageThreshold: {
  global: {
    branches: 30,  // 临时降低
    functions: 30,
    lines: 30,
    statements: 30
  }
}
```

### 问题3: Test timeout

**症状**:
```
thrown: "Exceeded timeout of 10000 ms for a test.
```

**原因**:
- 异步操作时间过长
- LLM调用超时

**解决方案**:
1. **增加测试超时时间**
```javascript
// 在测试文件中
jest.setTimeout(30000);

// 或在jest.config.cjs中
module.exports = {
  testTimeout: 30000
};
```

2. **优化测试中的异步操作**
```javascript
// 使用mock替代实际调用
jest.mock('../../src/utils/llmClient.js', () => ({
  __esModule: true,
  default: jest.fn().mockResolvedValue('mock response')
}));
```

---

## G2. 容器环境问题

### 问题1: 测试在容器中失败

**症状**:
- 测试在本地通过，但在Docker容器中失败
- 模块找不到或版本不匹配

**可能原因**:
1. Node版本不一致
2. 依赖版本不一致
3. 环境变量缺失
4. 网络连接问题

**解决方案**:
1. **检查Node版本**
```bash
# 本地
node --version
# 容器内
docker exec afs-system-server-1 node --version
```

2. **确认依赖版本一致**
```bash
# 检查package-lock.json是否已提交
git ls-files | grep package-lock.json

# 重新安装依赖
docker exec afs-system-server-1 npm ci
```

3. **检查环境变量**
```bash
# docker-compose.yml
environment:
  - NODE_ENV=development
  - MONGO_URI=mongodb://mongoserver:27017/afs
  - MODEL_SERVER_URL=http://modelserver:11434
```

4. **检查网络连接**
```bash
# 测试容器间连通性
docker exec afs-system-server-1 ping mongoserver
docker exec afs-system-server-1 ping modelserver
```

### 问题2: 文件权限问题

**症状**:
```
Error: EACCES: permission denied, open '/app/storage/userdata/test/file.json'
```

**原因**:
- 容器中的文件权限不正确
- 容器以root用户运行，但文件属于其他用户

**解决方案**:
1. **在Dockerfile中设置正确的用户**
```dockerfile
FROM node:18-alpine
WORKDIR /app
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001
USER nodejs
COPY --chown=nodejs:nodejs . .
```

2. **修改文件权限**
```bash
docker exec afs-system-server-1 chmod -R 755 /app/storage
docker exec afs-system-server-1 chown -R nodejs:nodejs /app/storage
```

3. **在docker-compose.yml中配置用户映射**
```yaml
services:
  afs-system-server:
    user: "1001:1001"
```

### 问题3: 端口冲突

**症状**:
```
Error: listen EADDRINUSE :::3000
```

**原因**:
- 宿主机端口已被占用
- 多个容器使用相同端口

**解决方案**:
1. **查找占用端口的进程**
```bash
# Linux/Mac
lsof -i :3001
# Windows
netstat -ano | findstr :3001
```

2. **修改端口映射**
```yaml
# docker-compose.yml
services:
  afs-system-server:
    ports:
      - "3002:3000"  # 改为其他端口
```

---

## G3. LangChain集成问题

### 问题1: LLM调用失败

**症状**:
```
Error: Failed to call LLM
Error: fetch failed
```

**可能原因**:
1. ModelServer未启动
2. 网络连接问题
3. 模型未加载
4. 超时时间过短

**解决方案**:
1. **确认ModelServer状态**
```bash
# 检查容器是否运行
docker ps | grep modelserver

# 检查容器日志
docker logs afs-system-modelserver-1

# 测试端点
curl http://localhost:8000/api/tags
```

2. **检查网络连接**
```bash
# 测试容器间连通性
docker exec afs-system-server-1 curl http://modelserver:11434/api/version

# 测试Docker网络
docker network ls
docker network inspect afs-system_default
```

3. **确认模型加载**
```bash
# 列出已加载的模型
curl http://localhost:8000/api/tags

# 加载模型（如果未加载）
curl -X POST http://localhost:8000/api/pull -d '{"name":"qwen2.5"}'
```

4. **增加LLMClient的超时配置**
```javascript
// LLMClient初始化
const llmClient = new LLMClient({
  model: 'qwen2.5',
  baseUrl: 'http://modelserver:11434',
  timeout: 60000,  // 增加到60秒
  maxRetries: 5
});
```

### 问题2: Ollama API响应格式不匹配

**症状**:
```
Error: Cannot read properties of undefined (reading 'content')
```

**原因**:
- Ollama API响应格式与LangChain预期不同
- 模型输出格式不一致

**解决方案**:
1. **查看实际响应**
```javascript
// 在LLMClient中添加日志
console.log('Ollama response:', response);
```

2. **处理不同的响应格式**
```javascript
// LLMClient中的适配代码
generate(prompt, options = {}) {
  const response = await this.model.invoke(prompt);
  
  // 处理不同的响应格式
  let content;
  if (response?.content) {
    content = response.content;
  } else if (response?.message?.content) {
    content = response.message.content;
  } else if (typeof response === 'string') {
    content = response;
  } else {
    throw new Error('Invalid response format from LLM');
  }
  
  return { content };
}
```

### 问题3: ChromaDB连接失败

**症状**:
```
Error: ChromaDB connection failed
Error: connect ECONNREFUSED 127.0.0.1:8000
```

**解决方案**:
1. **检查ChromaDB服务状态**
```bash
# 确认服务运行
docker ps | grep chroma

# 检查端口映射
docker port chroma-db-container
```

2. **更新连接配置**
```javascript
// ChromaDB客户端配置
const client = new ChromaClient({
  path: "http://chromadb:8000",  // 使用容器名而非localhost
  auth: undefined
});
```

---

## G4. 数据模型问题

### 问题1: MongoDB连接失败

**症状**:
```
Error: connect ECONNREFUSED 127.0.0.1:27018
```

**解决方案**:
1. **检查MongoDB容器状态**
```bash
docker ps | grep mongo
docker logs afs-system-mongoserver-1
```

2. **检查连接字符串**
```javascript
// 环境变量
MONGO_URI=mongodb://mongoserver:27017/afs

// 确认在docker-compose.yml中使用容器名
services:
  afs-system-server:
    environment:
      - MONGO_URI=mongodb://mongoserver:27017/afs
```

### 问题2: 数据库索引创建失败

**症状**:
```
Error: index build failed: cannot create index
```

**解决方案**:
1. **检查索引定义**
```javascript
// models/User.js
UserSchema.index({ 'companionChat.strangerSentiments.strangerId': 1 }); // 确保路径正确
```

2. **手动创建索引**
```javascript
// 在Mongo shell中
db.users.createIndex({ 'companionChat.strangerSentiments.strangerId': 1 });
```

### 问题3: 字段验证错误

**症状**:
```
ValidationError: Path `xxx` is required
```

**解决方案**:
1. **检查模型定义**
```javascript
// 确保required字段在模型中定义
UserSchema.add({
  companionChat: {
    type: Object,
    required: false,  // 新字段可能不是required
    default: {}
  }
});
```

2. **处理现有数据**
```javascript
// 为现有文档添加默认值
db.users.updateMany(
  { companionChat: { $exists: false } },
  { $set: { companionChat: {} } }
);
```

---

## G5. 服务集成问题

### 问题1: DualStorage文件系统错误

**症状**:
```
Error: ENOENT: no such file or directory, open '/app/storage/userdata/xxx/assistants-guidelines.json'
```

**解决方案**:
1. **创建目录结构**
```javascript
// 在DualStorage中确保目录存在
await fs.mkdir(path.join(this.basePath, userId), { recursive: true });
```

2. **检查权限**
```bash
docker exec afs-system-server-1 ls -la /app/storage/userdata/
```

3. **验证路径配置**
```javascript
// 确保basePath正确
const dualStorage = new DualStorage({
  basePath: '/app/storage/userdata'  // 绝对路径
});
```

### 问题2: SentimentManager计算错误

**症状**:
```
RangeError: Maximum call stack size exceeded
```

**解决方案**:
1. **检查递归调用**
```javascript
// 确保没有无限递归
updateSentiment(targetUserId, strangerId, updateData) {
  // ... 
  // 避免在updateSentiment内部调用自己
}
```

2. **添加保护机制**
```javascript
// 限制历史记录数量
if (sentiment.history.length > 100) {
  sentiment.history = sentiment.history.slice(-100);
}
```

### 问题3: API路由404错误

**症状**:
```
Cannot GET /api/sentiment/xxx/xxx
```

**解决方案**:
1. **确认路由已注册**
```javascript
// 在server.js中
app.use('/api/sentiment', sentimentRoutes);
```

2. **检查路由文件**
```javascript
// routes/sentiment.js
const router = express.Router();
router.get('/:targetUserId/:strangerId', async (req, res) => {
  // ...
});
module.exports = router;
```

3. **验证中间件顺序**
```javascript
// 确保auth中间件在路由之前
app.use('/api', authMiddleware);
app.use('/api/sentiment', sentimentRoutes);
```

---

## G6. Phase 3对话功能问题

### 问题1: 会话创建失败

**症状**:
```
Error: Cannot create session
Error: 目标用户不存在
```

**可能原因**:
1. uniqueCode不正确
2. 目标用户未完成A套问题
3. 目标用户未生成角色卡

**解决方案**:
1. **检查uniqueCode**
```bash
# 查询用户
curl http://localhost:3001/api/users/by-code/{uniqueCode} \
  -H "Authorization: Bearer {token}"
```

2. **检查角色卡是否生成**
```javascript
// 在MongoDB中查询
db.users.findOne({ uniqueCode: "your-code" }, {
  companionChat: 1
})
```

3. **提示用户**
- 如果未完成A套问题，提示用户先完成
- 如果未生成角色卡，提示用户先生成角色卡

---

### 问题2: 发送消息无响应

**症状**:
```
POST /api/chat/sessions/{sessionId}/messages
// 请求超时或无响应
```

**可能原因**:
1. 会话ID不存在
2. 会话已结束
3. LLM调用超时
4. LangGraph节点执行失败

**解决方案**:
1. **检查会话是否存在**
```bash
# 查询会话
curl http://localhost:3001/api/chat/sessions/{sessionId}/messages \
  -H "Authorization: Bearer {token}"
```

2. **检查会话状态**
```javascript
// 在MongoDB中查询
db.chatSessions.findOne({ sessionId: "session-id" }, {
  isActive: 1,
  endedAt: 1
})
```

3. **增加超时时间**
```javascript
// 在LLMClient中
const llmClient = new LLMClient({
  model: 'qwen2.5',
  timeout: 60000,  // 增加到60秒
  maxRetries: 5
});
```

4. **查看日志**
```bash
# 查看编排器日志
docker logs afs-system-server-1 | grep "ChatGraphOrchestrator"

# 查看节点日志
docker logs afs-system-server-1 | grep "InputProcessor"
docker logs afs-system-server-1 | grep "ResponseGenerator"
```

---

### 问题3: 好感度不更新

**症状**:
```
// 发送多条消息后，好感度始终为50
GET /api/sentiment/{targetUserId}/{strangerId}
{
  "currentScore": 50,
  "history": [...]
}
```

**可能原因**:
1. SentimentManager未正确集成到sentimentAnalyzerNode
2. 好感度更新失败但被静默处理
3. 数据库更新失败

**解决方案**:
1. **检查sentimentAnalyzerNode集成**
```javascript
// 确认sentimentAnalyzerNode在edges中被调用
export const edges = {
  // ...
  'sentiment_analyzer': 'context_builder'
};
```

2. **检查日志**
```bash
# 查看好感度更新日志
docker logs afs-system-server-1 | grep "SentimentManager"
```

3. **手动触发更新**
```bash
# 通过API手动更新
curl -X PUT http://localhost:3001/api/sentiment/{targetUserId}/{strangerId} \
  -H "Authorization: Bearer {token}" \
  -H "Content-Type: application/json" \
  -d '{
    "message": "测试消息",
    "conversationHistory": []
  }'
```

4. **检查数据库**
```javascript
// 在MongoDB中查询好感度记录
db.users.findOne({
  _id: ObjectId("target-user-id"),
  "companionChat.strangerSentiments.strangerId": ObjectId("stranger-id")
}, {
  "companionChat.strangerSentiments.$": 1
})
```

---

### 问题4: RAG检索不返回结果

**症状**:
```
// 与家人/朋友对话时，retrievedMemories为空
{
  "retrievedMemoriesCount": 0,
  "ragUsed": true
}
```

**可能原因**:
1. ChromaDB未启动
2. 用户没有相关记忆数据
3. ChromaDB连接配置错误

**解决方案**:
1. **检查ChromaDB状态**
```bash
# 检查容器
docker ps | grep chroma

# 检查端口
docker port chroma-db-container
```

2. **检查用户记忆数据**
```bash
# 查询文件系统
ls -la /app/storage/userdata/{userId}/chroma_db/

# 查询向量集合
curl http://localhost:8000/api/collections
```

3. **手动测试检索**
```javascript
// 在代码中手动调用DualStorage
const DualStorage = (await import('./dualStorage.js')).default;
const dualStorage = new DualStorage();

const memories = await dualStorage.retrieveMemories('测试查询', 'family');
console.log('检索结果:', memories);
```

4. **检查连接配置**
```javascript
// 确认ChromaDB连接地址
// ChromaDB客户端应使用容器名而非localhost
const client = new ChromaClient({
  path: "http://chromadb:8000"
});
```

---

### 问题5: LangGraph节点执行顺序错误

**症状**:
```
// 节点执行顺序不符合预期
// 例如：stranger关系时仍然执行了rag_retriever
```

**可能原因**:
1. edges.js中边定义错误
2. routeByRelation函数逻辑错误
3. relationConfirmNode未正确设置关系类型

**解决方案**:
1. **检查edges定义**
```javascript
// 确认边定义正确
export const edges = {
  'input_processor': 'relation_confirm',
  'relation_confirm': 'rolecard_assemble',
  'rolecard_assemble': 'route_by_relation',
  'rag_retriever': 'context_builder',
  'sentiment_analyzer': 'context_builder',
  // ...
};
```

2. **检查路由函数**
```javascript
// 确认路由逻辑正确
export function routeByRelation(state) {
  const relationType = state.interlocutor?.relationType || 'stranger';
  
  switch (relationType) {
    case 'family':
      return 'rag_retriever';
    case 'friend':
      return 'rag_retriever';
    case 'stranger':
      return 'sentiment_analyzer';
    default:
      return 'sentiment_analyzer';
  }
}
```

3. **添加调试日志**
```javascript
// 在ChatGraphOrchestrator.executeGraph中
logger.info(`[ChatGraphOrchestrator] 当前节点: ${currentNode}`);
logger.info(`[ChatGraphOrchestrator] 下一节点: ${nextNode}`);
```

---

### 问题6: 会话重启后状态丢失

**症状**:
```
// 服务器重启后，内存中的会话丢失
// 但ChatSession中的历史记录还在
```

**可能原因**:
1. ChatGraphOrchestrator的activeSessions是内存存储
2. 服务器重启后内存清空

**解决方案**:
1. **这是预期行为**
   - activeSessions仅用于缓存活跃会话
   - 历史记录持久化在MongoDB中

2. **用户重新发送消息**
   - 前端检测到会话失效
   - 提示用户重新创建会话
   - 或自动重新创建会话

3. **未来改进**
   - 实现Redis持久化缓存
   - 实现会话池化
   - 实现会话自动恢复

---

### 问题7: 并发请求导致数据不一致

**症状**:
```
// 多个用户同时发送消息时
// 消息顺序错乱或数据覆盖
```

**可能原因**:
1. 未实现并发控制
2. 多个请求同时修改同一会话
3. 数据库操作未使用事务

**解决方案**:
1. **添加并发控制（临时）**
```javascript
// 在ChatGraphOrchestrator中
class ChatGraphOrchestrator {
  constructor() {
    this.sessionsLocks = new Map();
  }
  
  async sendMessage(sessionId, message) {
    // 获取锁
    if (this.sessionsLocks.has(sessionId)) {
      throw new Error('会话正在处理中，请稍后再试');
    }
    
    this.sessionsLocks.set(sessionId, true);
    
    try {
      // 执行消息发送
      const result = await this.executeGraph(state);
      return result;
    } finally {
      // 释放锁
      this.sessionsLocks.delete(sessionId);
    }
  }
}
```

2. **前端排队处理**
```javascript
// 在前端实现消息队列
class MessageQueue {
  constructor() {
    this.queue = [];
    this.isProcessing = false;
  }
  
  async add(message) {
    this.queue.push(message);
    
    if (!this.isProcessing) {
      await this.process();
    }
  }
  
  async process() {
    this.isProcessing = true;
    
    while (this.queue.length > 0) {
      const message = this.queue.shift();
      await this.sendMessage(message);
    }
    
    this.isProcessing = false;
  }
}
```

3. **未来改进**
   - 使用Redis实现分布式锁
   - 实现消息队列（RabbitMQ、Kafka）
   - 使用数据库事务

---

### 问题8: LLM回复质量差

**症状**:
```
// AI回复不相关或质量很差
// 例如：回答问题不明确，重复内容等
```

**可能原因**:
1. System Prompt不完整
2. 记忆检索不准确
3. LLM模型配置不合适

**解决方案**:
1. **检查System Prompt**
```bash
# 查看日志中的systemPrompt
docker logs afs-system-server-1 | grep "System Prompt"

# 或在outputFormatterNode中打印
console.log('System Prompt:', state.systemPrompt);
```

2. **检查记忆检索结果**
```bash
# 查看检索到的记忆
docker logs afs-system-server-1 | grep "retrievedMemoriesCount"

# 检查记忆相关性
docker logs afs-system-server-1 | grep "RAGRetriever"
```

3. **调整LLM参数**
```javascript
// 在LLMClient中调整
const llmClient = new LLMClient('qwen2.5', {
  temperature: 0.7,  // 降低到0.3-0.5提高一致性
  maxTokens: 500,  // 增加到800允许更长回复
  maxRetries: 3
});
```

4. **优化RoleCard内容**
```javascript
// 在DynamicRoleCardAssembler中
// 确保个人画像详细、准确
// 确保对话准则清晰、具体
```

---

## H. 常用调试命令

### Docker相关
```bash
# 查看所有容器
docker ps -a

# 查看容器日志
docker logs afs-system-server-1

# 进入容器
docker exec -it afs-system-server-1 /bin/sh

# 重启服务
docker-compose restart afs-system-server
```

### 测试相关
```bash
# 运行特定测试
npm test -- --testNamePattern="specific test name"

# 调试模式
node --inspect-brk node_modules/jest/bin/jest.js --runInBand

# 更新快照
npm test -- --updateSnapshot
```

### 数据库相关
```bash
# 连接MongoDB
docker exec -it afs-system-mongoserver-1 mongo

# 查看集合
db.users.find().pretty()
db.chatSessions.find().limit(5)

# 检查索引
db.users.getIndexes()

# 查看好感度
db.users.findOne({
  "companionChat.strangerSentiments.strangerId": ObjectId("...")
}, {
  "companionChat.strangerSentiments.$": 1
})
```

### Phase 3相关
```bash
# 查看ChatGraph日志
docker logs afs-system-server-1 | grep "ChatGraphOrchestrator"

# 查看所有节点日志
docker logs afs-system-server-1 | grep -E "(InputProcessor|RelationConfirm|ResponseGenerator)"

# 查看重感度更新日志
docker logs afs-system-server-1 | grep "SentimentManager"

# 查看RAG检索日志
docker logs afs-system-server-1 | grep "RAGRetriever"

# 测试API端点
curl -X POST http://localhost:3001/api/chat/sessions/by-code \
  -H "Authorization: Bearer {token}" \
  -H "Content-Type: application/json" \
  -d '{"targetUniqueCode": "test-code"}'

# 发送测试消息
curl -X POST http://localhost:3001/api/chat/sessions/{sessionId}/messages \
  -H "Authorization: Bearer {token}" \
  -H "Content-Type: application/json" \
  -d '{"message": "你好"}'
```

---

**文档版本**: v1.1  
**创建日期**: 2026-02-05  
**作者**: AFS Team  
**最后更新**: 2026-02-07  
**更新内容**: 新增Phase 3对话功能故障排查